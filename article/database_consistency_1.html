<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="../favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		
		<link href="../_app/immutable/assets/0.BduBPsYz.css" rel="stylesheet">
		<link href="../_app/immutable/assets/2.CzhWGdCx.css" rel="stylesheet">
		<link href="../_app/immutable/assets/4.DwwtVzUN.css" rel="stylesheet">
		<link rel="modulepreload" href="../_app/immutable/entry/start.C90_pPfV.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/DmKrRu43.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/COc0ozwQ.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/CR_4RHM7.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/CaC1Krpq.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/BjM09ad5.js">
		<link rel="modulepreload" href="../_app/immutable/entry/app.Bg7HXQff.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/1-kU2YTO.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/Cew64nlL.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/CYQQZ9Kc.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/dbPvbsOE.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/0.DmQb1gwr.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/C5SEx9ip.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/BFQL34oP.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/2.CqSAoTFj.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/3ot0CaDB.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/DPMIOPX_.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/4.CtBbnhLD.js">
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents"><!--[--><!--[--><!----><div class="app svelte-1t5f27d"><header class="svelte-1wpzjs"><div class="title svelte-1wpzjs">Blog</div></header><!----> <main class="svelte-1t5f27d"><!--[--><!----><div class="article-layout svelte-10kcmdg"><aside class="svelte-10kcmdg"><nav class="svelte-h5mjvk"><h2 class="svelte-h5mjvk"><a href="../article" class="nav-heading-link">文章列表</a></h2> <!--[--><section><button class="category-toggle">Software</button> <!--[!--><!--]--></section><!--]--></nav><!----></aside> <main class="svelte-10kcmdg"><!----><!----><!--[--><article class="prose mx-auto"><div class="article-header svelte-1l2p5et"><h1 class="svelte-1l2p5et">Database Consistency 1</h1> <p class="svelte-1l2p5et">2025-07-28</p></div> <section class="article-body svelte-1l2p5et"><!----><h6>維持多台 Server 資料唯一性的幾種選擇，<a href="https://ithelp.ithome.com.tw/articles/10217086" rel="nofollow">建議閱讀這裡</a></h6> <hr/> <p>當需要維持多台DB Server，因為建置成本的關係，可依據需求去選擇不同強度的Model去實作</p> <h3>Consistency Model</h3> <ul><li><p>Strong Consistency: 在保證最新和正確的情況下才回傳，否則就回報錯誤</p></li> <li><p>Read My Writes: 只讀取保證有最新寫入的資料庫</p></li> <li><p>Bounded Staleness: 可參數化這個 bounded值，在可允許範圍內確定資料的正確性</p></li> <li><p>Consistent Prefix: 保證資料是正確的，但是不一定是最新</p></li> <li><p>Monotonic Reads: 第一次拿取不保證正確性，但之後都會向同一台Server拿取資料</p></li> <li><p>Eventual Consistency: 只保證最後執行完畢的資料會是正確的</p></li></ul> <h3>Quorum System</h3> <p>實例情境</p> <ul><li>商城限量開賣一款筆電限購「100台」</li> <li>客戶很多（C1、C2、C3…Cn）在同一時間湧進來搶購</li> <li>為了快速處理，商城把這個「庫存數量」存在於 <strong>3 個伺服器（R1、R2、R3）</strong> 上，形成一個「分散式系統」</li></ul> <br/> <h3>DB Lock</h3> <p>每次有人要搶購時，先「鎖住所有伺服器」，等操作結束後再開放。能保證正確（強一致性）但是非常慢、任一台伺服器壞掉，整個系統卡死。</p> <ul><li>客戶 A 說我要買 → 鎖住 R1、R2、R3 → 扣庫存 → 解鎖</li> <li>客戶 B 必須等待 A 的操作完</li></ul> <h3>Quorum</h3> <ul><li>寫入：只要成功寫入 <strong>2 台（W = 2）</strong> 就算成功</li> <li>讀取：也從 <strong>2 台讀取（R = 2）</strong></li> <li>且滿足 R + W > 3，就能保證「交集」裡一定有最新的資訊</li></ul> <br/> <p>對應實際流程：</p> <ol><li><p>客戶 A 要買向 R1、R2 發出購買請求（扣除庫存 -1），系統只要有 2 台回應成功就算成功。</p></li> <li><p>客戶 B 要買向 R2、R3 發出購買請求，就算不同人問到不同伺服器，只要 <strong>總是至少問 2 台（R）</strong>，系統就可以找出正確的庫存數，避免「同時兩人都以為還有庫存」。</p></li></ol> <pre class="language-text"><!----><code class="language-text">庫存初始值：100

伺服器：
R1: 100
R2: 100
R3: 100

C1 買一台：
→ 寫入 R1 和 R2（成功）
→ R1: 99, R2: 99, R3: 100

C2 買一台：
→ 讀 R2 和 R3，選出最大版本為 99
→ 寫入 R2 和 R3 → 變成 R2: 98, R3: 98

最後
R1: 99
R2: 98
R3: 98</code><!----></pre> <p><code>下次再讀庫存時 → 會從 2 台讀出資料 → 看哪個版本新（有版本號或時間戳）→ 拿到正確的「98」</code></p> <p>假設用戶 C1 買了一台筆電，寫入筆電數量剩下 99
C1 的請求被成功寫到：R1、R2、R3
R4(讀)、R5(讀) 當時故障或太慢 → 沒有更新成功</p> <pre class="language-text"><!----><code class="language-text">R1: 99
R2: 99
R3: 99
R4: 100
R5: 100</code><!----></pre> <h3>Read-Repair</h3> <pre class="language-text"><!----><code class="language-text">R1: 99  ✅（有時間戳 t2）
R4: 100 ❌（舊）
R5: 100 ❌（舊）</code><!----></pre> <p>系統根據 timestamp 判斷：99 是最新的庫存，除了把 99 回傳給用戶外，還會 99 寫回 R4、R5</p> <pre class="language-text"><!----><code class="language-text">R1: 99
R2: 99
R3: 99
R4: 99
R5: 99</code><!----></pre> <h3>Anti-Entropy</h3> <p>或是用背景 process 會：</p> <ul><li><p>定期掃描所有 replica</p></li> <li><p>發現某些節點資料版本較舊</p></li> <li><p>根據 timestamp 主動同步最新資料</p></li></ul> <br/> <h3>Sloppy Quorum + Hinted Handoff</h3> <p>之前的寫入規則是 R1, R2, R3 寫入 >= 2
但是如果_R3突然掛掉了，可以找一個替代伺服器_R4，只是_R4儲存的資料需要標記，等_R3恢復後再回補</p> <pre class="language-text"><!----><code class="language-text">C1 發出寫入 (搶購筆電，剩 99)

[ 原本應該寫入 ]:  R1   R2   R3  
[ 實際成功寫入 ]:  R1   R4   ❌

=&gt; 系統標記：R4 存了一份「R3 的代理資料」</code><!----></pre><!----></section></article><!--]--><!----><!----></main></div><!----><!--]--><!----></main></div><!----><!--]--> <!--[!--><!--]--><!--]-->
			
			<script>
				{
					__sveltekit_1ctgvvj = {
						base: new URL("..", location).pathname.slice(0, -1),
						assets: "/svelte-blog"
					};

					const element = document.currentScript.parentElement;

					Promise.all([
						import("../_app/immutable/entry/start.C90_pPfV.js"),
						import("../_app/immutable/entry/app.Bg7HXQff.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 2, 4],
							data: [null,null,null],
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
